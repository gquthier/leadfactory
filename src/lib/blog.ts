import type { BlogPost, BlogPostMeta, TableOfContentsItem } from '@/types/blog';

// Blog posts will be loaded from the virtual module generated by vite-plugin-blog
// This provides a type-safe way to access blog data

export function formatDate(dateString: string): string {
  const date = new Date(dateString);
  return date.toLocaleDateString('fr-FR', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });
}

export function formatDateShort(dateString: string): string {
  const date = new Date(dateString);
  return date.toLocaleDateString('fr-FR', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  });
}

export function calculateReadingTime(content: string): number {
  const wordsPerMinute = 200;
  const wordCount = content.trim().split(/\s+/).length;
  return Math.ceil(wordCount / wordsPerMinute);
}

export function getWordCount(content: string): number {
  return content.trim().split(/\s+/).length;
}

export function extractTableOfContents(html: string): TableOfContentsItem[] {
  const headingRegex = /<h([2-3])[^>]*id="([^"]*)"[^>]*>([^<]*)<\/h[2-3]>/gi;
  const toc: TableOfContentsItem[] = [];
  let match;

  while ((match = headingRegex.exec(html)) !== null) {
    toc.push({
      level: parseInt(match[1]),
      id: match[2],
      text: match[3].replace(/<[^>]*>/g, '').trim(),
    });
  }

  return toc;
}

export function generateSlug(text: string): string {
  return text
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/(^-|-$)/g, '');
}

export function addIdsToHeadings(html: string): string {
  return html.replace(
    /<h([2-3])([^>]*)>([^<]*)<\/h[2-3]>/gi,
    (match, level, attrs, text) => {
      const id = generateSlug(text);
      if (attrs.includes('id=')) {
        return match;
      }
      return `<h${level}${attrs} id="${id}">${text}</h${level}>`;
    }
  );
}

export function getRelatedPosts(
  currentPost: BlogPostMeta,
  allPosts: BlogPostMeta[],
  limit: number = 3
): BlogPostMeta[] {
  const otherPosts = allPosts.filter(
    (post) => post.slug !== currentPost.slug && !post.draft
  );

  // Score posts by tag overlap
  const scoredPosts = otherPosts.map((post) => {
    const commonTags = post.tags.filter((tag) =>
      currentPost.tags.includes(tag)
    );
    const commonCategories = post.categories.filter((cat) =>
      currentPost.categories.includes(cat)
    );
    return {
      post,
      score: commonTags.length * 2 + commonCategories.length,
    };
  });

  // Sort by score (desc) then by date (desc)
  scoredPosts.sort((a, b) => {
    if (b.score !== a.score) return b.score - a.score;
    return new Date(b.post.date).getTime() - new Date(a.post.date).getTime();
  });

  return scoredPosts.slice(0, limit).map((sp) => sp.post);
}

export function getAllTags(posts: BlogPostMeta[]): { tag: string; count: number }[] {
  const tagMap = new Map<string, number>();

  posts.forEach((post) => {
    if (!post.draft) {
      post.tags.forEach((tag) => {
        tagMap.set(tag, (tagMap.get(tag) || 0) + 1);
      });
    }
  });

  return Array.from(tagMap.entries())
    .map(([tag, count]) => ({ tag, count }))
    .sort((a, b) => b.count - a.count);
}

export function getAllCategories(posts: BlogPostMeta[]): { category: string; count: number }[] {
  const categoryMap = new Map<string, number>();

  posts.forEach((post) => {
    if (!post.draft) {
      post.categories.forEach((category) => {
        categoryMap.set(category, (categoryMap.get(category) || 0) + 1);
      });
    }
  });

  return Array.from(categoryMap.entries())
    .map(([category, count]) => ({ category, count }))
    .sort((a, b) => b.count - a.count);
}

export function filterPostsByTag(posts: BlogPostMeta[], tag: string): BlogPostMeta[] {
  return posts.filter((post) => !post.draft && post.tags.includes(tag));
}

export function filterPostsByCategory(posts: BlogPostMeta[], category: string): BlogPostMeta[] {
  return posts.filter((post) => !post.draft && post.categories.includes(category));
}

export function sortPostsByDate(posts: BlogPostMeta[], order: 'asc' | 'desc' = 'desc'): BlogPostMeta[] {
  return [...posts].sort((a, b) => {
    const dateA = new Date(a.date).getTime();
    const dateB = new Date(b.date).getTime();
    return order === 'desc' ? dateB - dateA : dateA - dateB;
  });
}

export function paginatePosts(
  posts: BlogPostMeta[],
  page: number,
  perPage: number
): { posts: BlogPostMeta[]; totalPages: number; currentPage: number } {
  const totalPages = Math.ceil(posts.length / perPage);
  const currentPage = Math.max(1, Math.min(page, totalPages));
  const start = (currentPage - 1) * perPage;
  const end = start + perPage;

  return {
    posts: posts.slice(start, end),
    totalPages,
    currentPage,
  };
}
